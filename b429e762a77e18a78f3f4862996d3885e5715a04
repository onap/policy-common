{
  "comments": [
    {
      "key": {
        "uuid": "da141535_2f0639cf",
        "filename": "common-logging/src/main/java/org/openecomp/policy/common/logging/flexlogger/FlexLogger.java",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 743
      },
      "writtenOn": "2017-06-09T16:29:28Z",
      "side": 0,
      "message": "Didn\u0027t this code serve a needed function? The method \u0027FlexLogger.getLogger()\u0027 would typically be called during static initialization -- are we guaranteed that \u0027FlexLogger\u0027 static initialization would always occur before the static initialization of classes referencing \u0027FlexLogger.getLogger()\u0027?",
      "revId": "b429e762a77e18a78f3f4862996d3885e5715a04",
      "serverId": "14b4e41f-c4e3-4fb9-9955-6a9b5656895a",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da141535_af77e9d3",
        "filename": "common-logging/src/main/java/org/openecomp/policy/common/logging/flexlogger/FlexLogger.java",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 477
      },
      "writtenOn": "2017-06-09T18:34:27Z",
      "side": 0,
      "message": "The class static section I believe it to be executed when class is loaded/initialized, before any instances or static methods can be invoked (so it is thread safe).   Under this belief, the code removed is ok as it is unnecessary.   Based on my tests, it seems to be working as I expected.\n\nThere were/are multiple issues with previous logging code, and in fact what that removed code was trying to achieve, it didn\u0027t.  I\u0027ve seeing output from the PolicyLogger.init() being hit more than once in junits.  So, it didn\u0027t guarantee one single invokation. Further, the previous initLogger() may never initialize the flag, and may be calling initLogger() every single time there is a getLogger() invocation, under the right set of conditions, such as absence of policyLogger.properties, or with parameters missing in the properties files (nullpointerexception issues).   Note in previous version, the flag was updated at the very end of initLogger() and there were paths for abortion.\n\nI think overall this improves several issues.\nI would hope we move away from FlexLogger in the future, so we can deprecate it at some point.",
      "parentUuid": "da141535_2f0639cf",
      "revId": "b429e762a77e18a78f3f4862996d3885e5715a04",
      "serverId": "14b4e41f-c4e3-4fb9-9955-6a9b5656895a",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da141535_ca49eb8c",
        "filename": "common-logging/src/main/java/org/openecomp/policy/common/logging/flexlogger/FlexLogger.java",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 743
      },
      "writtenOn": "2017-06-12T08:17:46Z",
      "side": 0,
      "message": "Note the output from running the following class:\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\npublic class Junk\n{\n  static String str1 \u003d initString(\"Initializing \u0027str1\u0027\");\n  static String str2;\n  static\n  {\n\tstr2 \u003d \"Initializing \u0027str2\u0027\";\n\tSystem.out.println(str2);\n  }\n  static String str3 \u003d initString(\"Initializing \u0027str3\u0027\");\n\n  private static String initString(String value)\n  {\n\tSystem.out.println(value);\n\treturn(value);\n  }\n\n  static public void main(String args[])\n  {\n\tSystem.out.println(\"Running \u0027main\u0027\");\n  }\n}\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n$ java Junk\nInitializing \u0027str1\u0027\nInitializing \u0027str2\u0027\nInitializing \u0027str3\u0027\nRunning \u0027main\u0027\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nNote that \u0027str2\u0027, is initialized after \u0027str1\u0027, even though \u0027str1\u0027 initialization is through a method, and \u0027str2\u0027 using a static block. Java does try to initialize dependencies before dependents, but I don\u0027t know if that always works as expected, particularly when there is the possibility of a dependency loop between classes.",
      "parentUuid": "da141535_af77e9d3",
      "revId": "b429e762a77e18a78f3f4862996d3885e5715a04",
      "serverId": "14b4e41f-c4e3-4fb9-9955-6a9b5656895a",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da141535_fe26b4b9",
        "filename": "common-logging/src/main/java/org/openecomp/policy/common/logging/flexlogger/FlexLogger.java",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 57
      },
      "writtenOn": "2017-06-12T14:49:44Z",
      "side": 0,
      "message": "Is this a singleton? I would recommend looking into using \u0027synchronized\u0027 during initialization even if you think it is thread-safe and works in your environment.",
      "parentUuid": "da141535_ca49eb8c",
      "revId": "b429e762a77e18a78f3f4862996d3885e5715a04",
      "serverId": "14b4e41f-c4e3-4fb9-9955-6a9b5656895a",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da141535_9e7338b1",
        "filename": "common-logging/src/main/java/org/openecomp/policy/common/logging/flexlogger/FlexLogger.java",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 477
      },
      "writtenOn": "2017-06-12T16:53:39Z",
      "side": 0,
      "message": "I think it is all ok as it is.  There is only one single call to initLogger() now, all other ones have been removed including the shared static data in this class.\n\nCheck this out: \n\nhttps://stackoverflow.com/questions/32976943/java-static-initialization-thread-safety-guarantee-in-language-spec \n\nand the reference to the section in the Java Language Specification that details the synchronized static initialization.\n\nI also corroborated it with this little multithreaded test program:\n\njh1730@newton:~/dev/open/LF/tmp$ cat StaticTest.java\nimport java.util.Date;\n\npublic class StaticTest {\n\n  public static volatile int count \u003d 0;\n\n  static {\n    count(\"start-static-block\", count);\n    System.out.println(\".... start 30 sec. sleep within static block ..\");\n    try {Thread.sleep(30000);} catch(Exception e) {e.printStackTrace();}\n    System.out.println(\".... end 30 sec. sleep within static block ..\");\n    count(\"end-static-block\", 1);\n  }\n\n  public StaticTest() {\n\tcount(\"constructor\",999);\n  }\n\n  public static void count(String m, int c) {\n    count\u003dc;\n    System.out.println(new Date() + \": \" + m + \" count\u003d\" + count);\n  }\n}\njh1730@newton:~/dev/open/LF/tmp$ \njh1730@newton:~/dev/open/LF/tmp$ cat Main.java\npublic class Main {\n\n  public static void main(String[] args) {\n    for (int i\u003d100; i\u003c110; i++) {\n      final int t\u003di;\n      new Thread() {\n      \t  public void run() {System.out.println(\".. thread-\" + t + \" ready to set count ...\"); StaticTest.count(\"thread-\"+t, t);}\n      }.start();\n    }\n\n    try {Thread.sleep(60000);} catch(Exception e) {e.printStackTrace();}\n  }\n}\njh1730@newton:~/dev/open/LF/tmp$ \njh1730@newton:~/dev/open/LF/tmp$ java Main\n.. thread-100 ready to set count ...\n.. thread-101 ready to set count ...\n.. thread-102 ready to set count ...\n.. thread-103 ready to set count ...\n.. thread-104 ready to set count ...\n.. thread-105 ready to set count ...\n.. thread-106 ready to set count ...\n.. thread-107 ready to set count ...\n.. thread-108 ready to set count ...\n.. thread-109 ready to set count ...\nMon Jun 12 11:49:32 CDT 2017: start-static-block count\u003d0\n.... start 30 sec. sleep within static block ..\n.... end 30 sec. sleep within static block ..\nMon Jun 12 11:50:02 CDT 2017: end-static-block count\u003d1\nMon Jun 12 11:50:02 CDT 2017: thread-102 count\u003d102\nMon Jun 12 11:50:02 CDT 2017: thread-103 count\u003d103\nMon Jun 12 11:50:02 CDT 2017: thread-101 count\u003d101\nMon Jun 12 11:50:02 CDT 2017: thread-104 count\u003d105\nMon Jun 12 11:50:02 CDT 2017: thread-105 count\u003d105\nMon Jun 12 11:50:02 CDT 2017: thread-109 count\u003d109\nMon Jun 12 11:50:02 CDT 2017: thread-108 count\u003d108\nMon Jun 12 11:50:02 CDT 2017: thread-106 count\u003d106\nMon Jun 12 11:50:02 CDT 2017: thread-100 count\u003d100",
      "parentUuid": "da141535_fe26b4b9",
      "revId": "b429e762a77e18a78f3f4862996d3885e5715a04",
      "serverId": "14b4e41f-c4e3-4fb9-9955-6a9b5656895a",
      "unresolved": false
    }
  ]
}